提供资源的计算机定义为peer
tracker服务器用于跟踪某个资源有哪些关联的peer

dht用于解决tracker服务器不可用的情况
将实现了dht协议的计算机定义为节点
通常，一个客户端既是peer，又是节点

dht翻译页面中关于peer与节点的定义
peer是指一个客户端或服务器监听一个tcp端口，经过这个端口的数据实现了bitTorrent协议
节点是指一个客户端或服务器监听一个udp端口，经过这个端口的数据实现了distributed hash table协议
dht由节点组成，dht存储了Peer的位置信息。
bittorrent客户端包含一个dht节点，用于联系dht网络中的其他节点，从而获得peer的位置信息，以便使用bittorrent协议来从peer那里下载内容。

dht网络有多种实现算法，如kademlia

资源的标识在dht网络中称为infohash,是一个20个字节长的字符串，一般通过sha1算法获得

kad的主要目的是查询某个资源对应的peer列表，而这个peer列表实际上是分散在整个网络中，网络中节点数量很大，如果要获得peer列表，最简单的做法无非是依次询问网络中的每个节点，这不可行。所以kad算法设立了一个路由表。每个节点都有一份路由表。有路由表之后 ，再通过一个基于距离关系的查找算法，就可以实现不用挨个遍历就找到特定的节点。

路由表
每个节点维护了一个由好的节点组成的路由表。路由表中的节点被用来作为dht网络中查询的起点。当其他节点发起查询时，路由表中的节点作为响应信息被返回。

不是所有的节点都是相等的。有些是好的，有些则不是。许多节点可以使用dht来发起查询和收到响应，但却不能响应其他节点发起的查询。每个节点的路由表必须包含已知的好的节点，这是非常重要的。如果一个节点在最近15分钟响应了我们发起的一个查询，这个节点被认为是好的。如果一个节点在最近15分钟响应了我们的一个查询同时向我们发起了一个查询，这个节点也被认为是好的。在15分钟处于不活动状态后，一个节点状态变成不确定的。当节点在对连续的多次查询都无法做出响应后，这些节点被认为是糟糕的。比起未知状态的节点，那些已知的好的节点被赋予更高的优先级。

路由表覆盖了节点id空间的全部，从0到2的160次方。路由表被细分成多个桶，每个桶占有id空间的一个分区。一个空表只有一桶，分区是id空间的全部。当一个id为n的节点被插入表时，它被放到这个桶里面(最小值，最大值)。一个空表只有一桶，所以任何一个节点必须在它的范围之内。每个桶只能保存k个节点，目前为8，直到桶满。当一个桶被已知的好的节点占满时，新的节点不会被加进来，除非节点Id在桶所拥有的id空间分区范围之内。在这种情况下，桶会被两个新桶所替代，每个新桶只拥有原桶地址范围的一半，原桶的节点会被分配到两个新桶中。对于一个新表只有一桶的情况，该桶总是被分成两个新桶，且新桶的地址范围分别是0到2的159次方，2的159次方到2的160次方。

当一个桶被好的节点占满时，新节点会被丢弃。如果桶中任何节点变坏了，它会被新节点所替代。如果桶中任何状态不确定的节点最新15分钟都没被访问，那么其中最近被访问的节点会被ping。如果被ping的节点响应了，那么下一个最近被访问的状态不确定的节点会被ping，直到其中有一个未能正常响应或者全部节点被证明是好节点。如果桶中的节点被Ping后没有正常响应，通常建议再试一次而不是直接丢弃该节点并替换成一个新的好节点。采用这种方式，表中的节点将都是稳定的、长时间运行的节点。

每个桶应该维护一个属性名叫“last changed”用来表明内容的新鲜度。当桶中的一个节点被ping了且它响应了，或者一个节点被加到桶中了，或者桶中的一个节点被替换了，该桶的“last changed”属性应该被更新。那些15分钟没有任何变化的桶应该被刷新。刷新是指在该桶的地址范围内找一个随机的节点id，并对其执行find_nodes操作。那些能收到其他节点发送查询请求的节点通常不需要经常刷新它的桶。那些收不到其他节点发送查询请求的节点通常需要定期刷新它的全部的桶以确保当需要dht时，它的表中有好的节点存在。

当向节点的路由表中插入第一个节点时，以及系统启动后，该节点应该在dht网络中找到离自己最近的节点。实现方式是向那些离自己近的节点递归发送find_node消息，直到找不到更近的节点为止。在客户端软件的请求过程中，路由表应该被保存下来。

bittorrent协议升级
bittorrent协议已经被升级了,用来在tracker提供的peer之间交换节点udp端口号。通过这种方式，客户端能够通过下载正常的torrents文件来自动填充它们的路由表。那些尝试下载无tracker的torrent的新安装的客户端第一次尝试时将不会有任何节点存在于路由表中，将会需要包含在torrent文件中的节点信息。

支持dht的peer会在bittorrent协议的握手消息中将8字节的保留标记的最后一位置1。那些收到表明远程peer支持dht的握手消息的peer应该发送一个PORT消息。这个消息以字节0x09开始，包含dht节点的2个字节的udp端口号，以网络字节序。收到这个消息的peer，应该向发送方节点进行ping操作，ping操作的目标端口和Ip就是PORT消息中所包含的。如果Ping操作的响应被收到了，那么节点应该根据之前提到的通用规则将这个新的联系人信息加入到自己的路由表中。

上面描述的场景如下：
节点A向外发一个握手消息
节点B收到了，并回发一个PORT消息
节点A根据PORT消息中的IP和端口发一个ping消息
节点B回复Ping消息
节点A将节点B加入到自己的路由表中

torrent文件升级
一个不带track信息的torrent字典不存在"announce"键。相反，它包含一个"nodes"键。这个键应该被设置为生成该torrent的客户端的路由表中第k近的节点。或者，这个键可以被设置为一个已知的好节点，例如生成这个torrent的那个人所能操作的一 个节点。请不要自动的把"router.bittrent.com"添加到torrent文件中，或者自动把这个节点加入到客户端的路由表中。
nodes = [["<host>", <port>], ["<host>", <port>], ...]
nodes = [["127.0.0.1", 6881], ["your.router.node", 4804]]

KRPC协议
KRPC协议是一个简单的RPC机制，由B-encode编码的字典组成，通过UDP发送。一个简单的查询包发送出去，会有一个简单的响应包回复。没有重试。它有三种消息类型：查询、响应、错误。对于dht协议，查询类型有四种:ping、find_node、get_peers、announce_peer。

一个KRPC消息就是一个简单的字典，包含了适用于所有消息的三个通用键，根据消息的类型，也有会附加键。每个消息有一个t键，它的值是字符串，代表transactionId。transactionId由查询节点生成，会在响应消息里被输出，所以响应可能会与指向同一节点的多个查询相关联。transactionId应该被由二进制数组成的短字符串，通常情况下2个字符已经足够了，因为它能表示2的16次方的不同的查询。每个消息也会有一个y键，包含一个字符的值，表示消息的类型。当y键的值为q时代表查询，r代表响应，e代表错误。每个消息包含一个v键，包含一个客户端的版本字符串。这个字符串应该是由注册在BEP20中的2个字符的客户端标识开始，紧跟着两个字符的版本标识。不是所有的客户端实现者都包含了v键，所以客户端软件不应该假设此键一定会存在。

联系人编码
关于peer的联系信息被编码成6个字节的字符串。也被叫做打包的ip地址和端口信息。由4个字节的ip地址(网络字节序)，后面跟着2个字节的端口端口(网络字节序)。

关于节点的联系信息被编码成26个字节的字符串。也被叫做打包的节点信息。由20个字节的节点id(网络字节序)，后面跟着打包的ip地址和端口信息。

查询
查询，(或者KRPC消息，字典中的y键的值为q)，包含两个附加键：q、a。q键包含一个字符串的值，代表查询的方法名。a键的值是一个字典，包含查询的参数(带名字)。

响应
响应，(或者KRPC消息，字典中的y键的值为r)，包含一个附加键：r。r键的值是一个字典，包含了带名字的返回值。当查询成功时，响应消息会被送出。

错误
错误，(或者KRPC消息，字典中的y键的值为e)，包含一个附加键：e。e的值是一个列表。第一个元素是代表错误代码的整数值。第二个元素是代表错误信息的字符串。当查询不能被执行时，错误信息被送出。

dht查询
所有的查询包含一个名为id的key，值为发起查询的节点的节点id。所有的回复包含一个名为id的key，值为响应节点的节点Id。

ping
最基本的查询是ping。"q"="ping"。一个ping查询含有一个参数，名为id，值为20字节的字符串，表示发送节点的节点id(网络字节序)。相应的回复含有名为id的key，表示响应节点的节点Id。

find_node
find_node被用来根据一个节点的Id来查找该节点的联系信息。"q"="find_node",一个find_node查询含有两个参数，id包含发起查询的节点的Id,target包含查询者要搜索的目标节点Id。当一个节点收到一个find_node查询，它的回复信息应该包含nodes，值是一个字符串，包含搜索目标节点的打包节点信息，或者它的路由表里(离目标节点)最近的k(8)个好节点的打包节点信息。

get_peers
获取与一个torrent的infohash关联的peers。"q"="get_peers",一个get_peers查询包含两个参数，id包含发起查询节点的节点Id，info_hash包含torrent的infohash。如果被查询的节点含有peers for the infohash,它们会返回values，这是一个字符串列表，每个字符串包含一个peer的打包格式化Peer信息。如果被查询的节点没有peers for the infohash,它们会返回values,这里面包含了从被查询节点的路由表里找出的离infohash最近的k个节点。不管是哪种情况，返回信息里都会包含一个token。token的值是将来发起announce_peer查询所必需的参数。token值应该是一个短的二进制字符串。

announce_peer
发送这样一个通知：控制着发起查询节点的那个peer,正在一个端口上下载一个torrent。announce_peer有4个参数：id包含发起查询的节点的节点id，info_hash包含torrent的infohash，port是端口，token是之前get_peers查询的响应消息中的一个参数。被查询的节点需要验证该token已经被发送到和查询节点相同的ip地址上。然后被查询的节点应该存储发起查询的节点的ip地址，和其所提供的端口号到它自己的peer联系信息的仓库中。

有一个可选的参数叫implied_port，它的值是0或1。如果该参数存在且值非0，那么port参数应该被忽略，udp数据包的源端口号应该被当作peer的端口号。这是有用的，当peer处在nat中，可能不知道自己的外网端口，且支持uTP,它们在dht端口上接收传入的连接。