bencoding
字符串:		len:string					
	例子，4:spam表示spam

整数:		前缀i，后缀e,中间整数		
	例子，i3e表示3，i-3e表示-3，i0e表示0，其他情况下，如果整数有前缀0，则非法;i-0e也是非法

列表:		前缀l，后缀e，中间是元素	
	例子，l4:spam4:eggse表示['spam','eggs']

字典：		前缀d，后缀e,中间是key-value的列表
	例子，d3:cow3:moo4:spam4:eggse表示{'cow':'moo','spam':'eggs'}
	例子，d4:spaml1:a1:bee表示{'spam':['a','b']}
	key必须是字符串，按原始字符串的位置编码，而不要按文字顺序排序
	

	

metainfo文件
metainfo文件(也就是.torrent文件)是bencoding编码的字典，包含以下key

announce
	tracker的url
	
info
	这映射到了一个字典，key会在下面进行解释
	
.torrent文件里面所有字符串包含的文本必须是utf-8编码。	



info字典
name是一个utf-8编码的字符串，表示存储文件时推荐的文件名。
piece_length表示文件被分割后每块数据的字节数。为了便于传输，文件被分割成固定块数，每块数据大小一样，除了最后一块可能会不一样。piece_length基本上都会是2的指数。最可能的情况是2的18次方，也就是256K。(bittorrent3.2版本之前的软件使用2的20次方，也就是1M作为默认值)。
pieces指向一个字符串，其长度是20的倍数。每20个字符串是每个文件块对应自己所在索引的哈希值，采用SHA1算法。

还存在一个length key或files key, 但它们不会都存在,或都不存在. 如果存在length, 那么本次下载是个单文件， 否则的话，它代表是一组文件，以文件夹的形式。

如果是单个文件，length代表了该文件的字节长度

对于其他key的用途，多文件的情况被当作只有一个文件，通过把文件列表中的文件按出现的顺序一个个连接起来。这就是files key。这是一个字典的列表，包含如下key
length 文件的字节长度
path 一个utf-8编码的字符串列表，对应每个子目录的名，最后一个是文件名，如果是空列表，表明出错了

单文件的情况下，name key代表文件的名字，而在多文件情况下，它是目录的名字







trackers
tracker GET请求有以下Key

info_hash
将metainfo文件中的info值的bencoding编码形式进行sha1哈希后得到的20字节。这个值几乎肯定会被escaped。
TODO

peer_id
下载者使用此值作为其id,它是长度为20的字符串。每个下载者在开启一个新的下载时会生成一个随机的Id。这个值几乎也肯定会被escaped。

ip
可选参数，给出peer所在的ip。通常用来当作原始做种者如果它跟tracker在同一台机器上。

port
指出peer所监听的端口。通常的操作是这样的，一个下载者试图在6881端口上监听，如果被占用了，就试6882，然后6882，依次如下，6889后不再重试。

uploaded
目前为止上传总数，采用10进制ascii编码

downloaded
目前为止下载总数，采用10进制ascii编码

left
该peer还需要下载的字节数，采用10进制ascii编码。注意这不能通过已下载数和文件长度来计算出来，因为它可能是一个resume,也有可能已下载的数据校验失败，需要重下。

event
这是一个可选的key,映射到以下值：started、completed、stopped、empty(等同于该key不存在)。如果该key不存在，这是一个定期通知的其中的一个。一个使用started的通知会被发送，如果一个下载第一次开始时。如果下载结束时，带completed的通知会被发送。当下载开始时，发现文件其实下载完了，completed通知不会发送。当下载者中断下载时，带stopped的通知会被发送。

tracker的响应是bencoding编码的字典。如果tracker响应包含failure reason,这表示是一个可供人理解的字符串，解释了为什么查询失败了，这种情况下，没有别的Key存在。否则的话，有两个key是必需的：interval，表示下载者在正常的请求之间所需要等待的秒数；peers，这是一个字典的列表，对应于相应的peers。包含了以下key:peer_id、ip、port，分别代表peer id,ip地址或dns名称以字符串的形式，和相应的端口号。请注意，当有事件发生时或者需要更多peer时，下载者可能会重新发送请求，并没有按照他们应该等待的时间。

更通常的情况是tracker返回一个关于peer列表的打包的表现形式，参考BEP23

如果想对metainfo文件或tracker请求进行扩展，请与Bram Cohen协调来确保所有的扩展都相互兼容。

使用udp tracker协议进行通讯也是很通用的。







peer协议
bittorrent的peer协议通过tcp或utp来传输。

peer连接是对称的。两个方向传输的消息看起来是一样的。数据可流向任何一个方向。

peer协议通过索引来指向文件的每一块，索引在metainfo文件中有定义，从0开始。当一个peer下载完一块数据且校验成功，它向自己的peers通知我有这一块数据。

连接包含两个状态位，分别在连接的两端:choked、interested。阻塞是一个通知表示没有数据会被发送直到疏通发生了。关于阻塞的原因和技巧会在本文档的后面解释。

当连接的一端的状态是interested，另一端的状态不是阻塞时，数据传输会发生。interested的状态必须一直保持是最新的状态-当一个下载者不再向一个非阻塞的peer要东西时，它必须表示自己没有interest，不管是否阻塞了。实现这个机制是要花点技巧的，但它让以下情况变得可能：当变成非阻塞时，下载者就知道哪些peer立刻开始了下载。

连接刚开始的状态是阻塞的和not interested.

当数据被传输时，下载者应该一次同时入队多块数据的请求，来获得好的TCP性能(这叫做管道化)。另一方面，那些不能被立刻写出到tcp缓存的请求应该在内存中排队，而不是被保存在应用程序级别的网络缓存中，这样当阻塞发生时，它们会被立刻扔出去。

peer连线协议由一个握手，后面再跟上一个永不结束的带长度前缀的消息流组成。握手由10进制的19开始，后面跟上字符串"BitTorrent protocol"。起始字符是一个长度前缀，它存在的意义在于希望新协议也这样做，这样可以区分出是哪个协议。

所有之后的整数在发送时都会编码成4字节，并采用大端模式。

在固定头之后，是8个保留字节，当前的所有实现中，这些值全为0。如果你希望使用这些字节来扩展协议，请与Bram Cohen协商来确保所有的扩展是兼容的。

接下来是20字节的sha1哈希，哈希的内容是metainfo文件中的info值的bencode编码形式。(这跟通知到tracker消息中的info_hash是一样的，只是在这里它是原始值，在那里它被引号引起来了)。如果两边没有发送相同的值，那个连接被建立。唯一的例外是如果一个下载者想在一个端口上进行多个下载，它们可能会等待传入的连接先给一个下载哈希，如果它在它们的下载列表中，就会回复相同的信息。

在下载哈希之后，是20字节的Peer id，tracker请求中会有peer id,tracker响应中的peer lists也会包含peer id。如果响应端的peer id与发起端希望的不同，连接被建立。

到这里，握手信息就完了，接下来是一个可选的流，包含长度前缀和消息。长度前缀为0的消息包括保活、忽略。保活消息通常每两分钟发送一次，但要注意，当期望数据到来时，超时时间会比这更短。








peer消息
所有非保活消息开头的第一个字节代表它们的类型
以下是可能的值：
0-choke
1-unchoke
2-interested
3-not interested
4-have
5-bitfield
6-request
7-piece
8-cancel

choke、unchoke、interested、not interested不带消息体

bitfield是发送的第一个消息。它的消息体是一个位段与索引相对应。下载者已经发送的索引对应的位被置1，其余的被置0.下载者目前啥也没有的可能会跳过‘bitfield’消息。位段的第一个字节对应于索引0-7，从高位到低位。下一个字节对应8-15，以此类推。最后多余的位被置0.

have消息体是一个数，代表一个索引，下载者刚下载完，并校验

request消息包含index、begin、length。后两个字段是字节偏移。length通常是2的指数，除非它到达文件的末尾。所有当前的客户端实现都使用了2的14次方(16k)，当一个连接请求了比这个值更大的数，连接会被关闭。

cancel的消息体跟request消息体是一样的。这个消息通常会被发送当一个下载快要完成时，也就是进入所谓的‘endgame模式’。当一个下载快完时，情况通常是最后的几个数据块都要从一个低带宽的modem线路中下载，超耗时。为了确保最后几块数据的消息快速到来，一个下载者会请求自己所没有的那些数据块，一旦这些请求挂起了，它会向自己正在下载的所有目标方去请求everything。为了防止这样做超级低效率，每次当piece消息到达时，它会向其他人发送取消信息。

piece消息体包含index、begin、piece。要注意piece消息是与request消息隐式一一对应的。也有可能piece消息会不期而至，如果choke和unchoke消息快速连续地被发送，且(或)传输进行地非常缓慢。

下载者通常会随机下载数据块。这针对以下情况非常有帮助，就是下载者含有它们的peer的所含有的数据块的严格子集或超集。

阻塞机制的建立有多种原因的。当一次在多个连接上发送数据时，TCP的拥挤控制会很低效。同时阻塞机制使每个peer采用一报还一报的算法来保证它们能得到稳定的下载速率。

下面描述的阻塞算法是目前采用的一种。有个信息是很重要的，就是所有的新算法要同时能在多种网络环境中工作得很好，不管是网络中存在多种阻塞算法，还是只有这一种。

好的阻塞算法要达到几个标准。它需要控制并发上传的个数来保证好的TCP性能。它要避免在阻塞与非阻塞状态下快速切换，这种情况也称做‘纤维性颤动’。它应该对那些让它下载的peer做出相应的报答。最后，它应该隔段时间尝试一下那些没有使用的连接，来判断是否比当前使用的连接效果更好，这也叫做‘乐观的解锁’。

当前发布的阻塞算法通过以下做法来避免‘纤维性颤动’：它每隔10秒才会解锁那些曾经处于阻塞状态的对象。它的报答机制及限制上传并发数是：解锁4个它感兴趣的且它下载最快的peer。那些上传很快但不感兴趣的peer会被阻塞，当它们变成感兴趣的，那些慢速的上传者会被阻塞。当下载者有了一个完整的文件，它使用上传速度还不是下载速度来决定去解锁谁。

对于‘乐观解锁’机制，在任一时刻，只有一个peer会被解锁，而不考虑它的上传速度(如果是感兴趣的，它会被算在4个允许下载者之中）每30秒，‘乐观解锁’会触发一次。为了保证一个完整的块有机会被上传，新连接会被用3次。